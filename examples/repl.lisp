;; A Lisp REPL written in Lisp, based on `interpreter.lisp`.

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))

(define (eval exp env)
  (cond ((number? exp) exp)
        ((atom? exp) (lookup exp env))
        ((eq? (car exp) 'quote) (cadr exp))
        ((eq? (car exp) 'lambda) (list (cdr exp) env))
        ((eq? (car exp) 'cond) (evcond (cdr exp) env))
        ((eq? (car exp) 'car) (car (eval (cadr exp) env)))
        ((eq? (car exp) 'cdr) (cdr (eval (cadr exp) env)))
        ((eq? (car exp) 'cons)
         (cons (eval (cadr exp) env) (eval (caddr exp) env)))
        ((eq? (car exp) '+)
         (+ (eval (cadr exp) env) (eval (caddr exp) env)))
        ((eq? (car exp) '-)
         (- (eval (cadr exp) env) (eval (caddr exp) env)))
        ((eq? (car exp) '*)
         (* (eval (cadr exp) env) (eval (caddr exp) env)))
        ((eq? (car exp) '/)
         (/ (eval (cadr exp) env) (eval (caddr exp) env)))
        ((eq? (car exp) 'eq?)
         (eq? (eval (cadr exp) env) (eval (caddr exp) env)))
        ((eq? (car exp) '=)
         (= (eval (cadr exp) env) (eval (caddr exp) env)))
        ((eq? (car exp) 'define)
         (set-car! env (cons (cons (cadr exp) (eval (caddr exp) env)) (car env))))
        ('t
         (apply (eval (car exp) env)
                (evlist (cdr exp) env)))))

(define (apply proc args)
  (eval (cadar proc)
        (bind (caar proc) args (cadr proc))))

(define (evlist l env)
    (if (eq? l '())
        '()
        (cons (eval (car l) env)
              (evlist (cdr l) env))))

(define (evcond clauses env)
    (cond ((eq? clauses '()) '())
          ((eval (caar clauses) env) (eval (cadar clauses) env))
          ('t (evcond (cdr clauses) env))))

(define (bind vars vals env)
  (cons (pair-up vars vals) env))

(define (pair-up vars vals)
    (if (eq? vars '())
        '()
        (cons (cons (car vars) (car vals))
              (pair-up (cdr vars) (cdr vals)))))

(define (lookup sym env)
    (if (eq? env '())
        (display "ERROR: unbound environment\n")
        (let ((vcell (assq sym (car env))))
          (if (eq? vcell '())
              (lookup sym (cdr env))
              (cdr vcell)))))

(define (assq sym alist)
  (cond ((eq? alist '()) '())
        ((eq? sym (caar alist)) (car alist))
        ('t (assq sym (cdr alist)))))

(define cur_env '(((t t))))

(define (loop)
  (display "> ")
  (let ((value (eval (read) cur_env)))
    (display "= ")
    (display value)
    (newline))
  (loop))

(loop)
