# How to Create and Use Relic Packages

## Package from Lisp Code

Suppose that you have a `mylib.lisp` and want to use its variables elsewhere:
```lisp
; mylib.lisp
(define (add x y) (+ x y))
(define (neg x) (- 0 x))
(define answer 42)
```

All you need to do is to compile the Lisp code to a shared library and move it to this folder:
```sh
cargo run -- compile -i mylib.lisp -o mylib.c -p mylib
clang -Ic_runtime -shared -o lib/mylib.relic mylib.c
```

Then you can import use it in other lisp files:
```lisp
; other_file.lisp
(import mylib)
(add 2 3)
(neg answer)
```

The compilation flag of `other_file.lisp` is the same as normal files.

### How does it Work

When compiling `mylib` as a package (with `-p` flag), instead of generating a `main` function, the compiler generates a `mylib` function that defines `add`, `neg` and `answer` symbol.

The runtime will try to load `lib/mylib.relic` if the program calls `(import mylib)`. Then it runs the `mylib` function, adding the symbols to the current environment.

The runtime maintains a hash map of opened packages. `mylib` will be added to the map when you call `(import mylib)`. If `mylib` is in the hash map, the `mylib` function will not be called when `(import mylib)` is called.

## Wrapping C Functions to a Package

Suppose you want to wrap the following C function to a Relic package `my_package`:
```c
int func1(double x, long long y, const char *z);
void func2();
```

1. Create a `void()` wrapper function for `func1` and `func2`:
   ```c
   void func_1_wrapper() {
       // get parameters from the environment
       double x = rt_get_float(rt_get("#0_func_[func1_id]"));
       long long y = rt_get_int(rt_get("#1_func_[func1_id]"));
       const char *z = rt_get_symbol(rt_get("#1_func_[func1_id]"));

       int result = func1(x, y, z);

       // send the return value to the runtime
       rt_new_integer(result);
   }
   void func_2_wrapper() {
       func2();

       // send a `nil` to the runtime to indicate that the function returns nothing
       rt_new_symbol("nil");
   }
   ```
   Where `[func1_id]` can be anything as long as it does not clash with other function names (including the ones generated by the compiler using `format!("{some_integer}")`).
   
   You don't need a wrapper function for `func2` since it is already `void()`.
2. Create a C function `my_package` that calls `rt_new_closure()` and `rt_define()`:
   ```c
   #include "runtime.h"
   int my_package() {
       // The params of `rt_new_closure`:
       // 1. Function ID.
       // 2. Pointer to the function. 
       // 3. Number of parameters.
       // 4. Whether the closure is variadic. This should always be false for C functions.
       rt_new_closure("[func1_id]", func_1_wrapper, 3, false);
       rt_define("[func1_name]", rt_pop());
       rt_new_closure("[func2_id]", func2, 0, false);
       rt_define("[func2_name]", rt_pop());
   }
   ```
   Replace `[func1_name]` and `[func2_name]` with the name you want to call them in Relic The function name must be a valid symbol.
3. Compile everything to a shared library and move it to `lib/my_package.relic`.
4. Then you can call your function in Relic:
   ```lisp
   (import my_package)
   (display ([func1_name] 1 2.3 hello))
   ([func2_name])
   ```

Some notes:
- Currently Relic only has 3 primitive types: 64-bit integer, 64-bit floating point number and symbol. User-defined symbols can be transformed from (or to) C string. Boolean values are transformed to symbol `t` and `nil`.
- See [runtime.h](../c_runtime/runtime.h) and [lib.rs](../src/lib.rs) for the complete C API.
- See [SDL2 package](../examples/sdl2/) for an example of creating (and using) C bindings.
