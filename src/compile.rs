//! The compiler module.

use std::{collections::HashMap, fmt::Display};

use crate::{
    lexer::Number,
    node::{Node, Pattern},
    symbol::{SpecialForm, Symbol},
    util::{get_n_params, inc, vectorize},
};

/// Type of code generators.
pub enum CodeGenType {
    /// The generator is generating a closure that will not be used by other
    /// programs.
    Internal(usize),
    /// The generator is generating `main` function.
    Main,
    /// The generator is generating the top-level function that can be used.
    /// by other programs.
    Library(String),
}

/// Code generator.
///
/// A code generator is responsible for writing one function's code.
///
/// When the compiler needs to create a closure, it creates a new generator
/// to write the closure's code, then merge the new generator into the old one.
///
/// After compilation, the generator for the main function will have the same
/// layout as the compiled C source code.
pub struct CodeGen {
    /// The code generator's type.
    ty: CodeGenType,
    /// Closures. Values are function body without boilerplate.
    closures: HashMap<usize, String>,
    /// Body of the function the generator is writing.
    body: String,
}

impl CodeGen {
    pub fn new_main() -> Self {
        CodeGen {
            ty: CodeGenType::Main,
            closures: HashMap::new(),
            body: String::new(),
        }
    }
    fn new_internal(id: usize) -> Self {
        CodeGen {
            ty: CodeGenType::Internal(id),
            closures: HashMap::new(),
            body: String::new(),
        }
    }
    pub fn new_library(name: String) -> Self {
        CodeGen {
            ty: CodeGenType::Library(name),
            closures: HashMap::new(),
            body: String::new(),
        }
    }

    fn append_code(&mut self, code: &str) {
        self.body += code;
    }
    /// Merge the generator of a function created by this generator's function.
    fn merge(&mut self, func: Self) {
        if let CodeGenType::Internal(id) = func.ty {
            self.closures.extend(func.closures);
            assert!(self.closures.insert(id, func.body).is_none());
        } else {
            panic!("Merging top-level generator: {func}");
        }
    }
}

macro_rules! return_nil {
    ($codegen:expr, $ctx:expr) => {
        if !$ctx.drop_ret {
            $codegen.append_code("rt_new_symbol(\"nil\");");
        }
    };
}

macro_rules! set_family {
    ($func_name:expr, $target:expr, $cdr:expr, $codegen:expr, $ctx:expr, $dbg_info:expr) => {{
        let params = get_n_params($cdr.clone(), 2)?;
        let sym = &params[0];
        let expr = &params[1];
        let name = sym.borrow().as_user_symbol()?;
        expr.borrow().compile(
            $codegen,
            ContexInfo {
                drop_env: false,
                drop_ret: false,
            },
            $dbg_info,
        )?;
        $codegen.append_code(&format!("rt_{}({}, rt_pop());", $func_name, $target(name)));
        return_nil!($codegen, $ctx);
        Ok(())
    }};
}

impl Display for CodeGen {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let (func_name, start_code) = match &self.ty {
            CodeGenType::Internal(id) => panic!("Writing internal closure {id}"),
            CodeGenType::Main => ("main".to_string(), "rt_start();".to_string()),
            CodeGenType::Library(name) => (name.to_string(), String::new()),
        };
        let main_body = &self.body;

        for name in self.closures.keys() {
            writeln!(f, "static void func_{name}();")?;
        }
        writeln!(
            f,
            r#"
#include"runtime.h"
int {func_name}() {{
    {start_code}
    {main_body}
    return 0;
}}"#,
        )?;
        for (name, body) in &self.closures {
            writeln!(
                f,
                r#"
static void func_{name}() {{
    {body}
}}"#
            )?;
        }
        Ok(())
    }
}

/// Context information that can be used in optimization.
#[derive(Debug, Clone, Copy)]
struct ContexInfo {
    /// Whether to drop the current environment or keep it in the stack.
    ///
    /// When this field is `true`:
    /// - If the statement does not have side effect, then the entire code
    ///   won't be generated.
    /// - If the statement has side effect, then the return value won't be
    ///   pushed to the stack.
    drop_env: bool,
    /// Whether to drop the return value or keep it in the stack.
    ///
    /// In the code generated by our compiler, environment is callee-saved,
    /// i.e. the callee should save and restore the enviromnemt. If this field
    /// is true, then the callee doesn't need to restore the environment.
    drop_ret: bool,
}

/// Calls [Node::compile] with no optimization at the top level.
pub fn compile(node: &Node, codegen: &mut CodeGen, dbg_info: bool) -> Result<(), String> {
    node.compile(
        codegen,
        ContexInfo {
            drop_env: false,
            drop_ret: false,
        },
        dbg_info,
    )
}

/// The trait that defines a way to compile the object.
trait Compile {
    /// Compile the object.
    ///
    /// The semantics of the compiled code is to evaluate this object and push
    /// its value to the stack.
    ///
    /// If `dbg_info` is true, a special statement will be inserted at the end
    /// of each evaluation to support `n` command in the debugger.
    fn compile(&self, codegen: &mut CodeGen, ctx: ContexInfo, dbg_info: bool)
    -> Result<(), String>;
}

impl Compile for Symbol {
    fn compile(
        &self,
        codegen: &mut CodeGen,
        ctx: ContexInfo,
        _dbg_info: bool,
    ) -> Result<(), String> {
        if !ctx.drop_ret {
            let code = match self {
                Symbol::User(name) => {
                    format!("rt_push(rt_get(\"{name}\"));")
                }
                _ => {
                    format!("rt_new_symbol(\"{self}\");")
                }
            };
            codegen.append_code(&code);
        }
        Ok(())
    }
}

impl Compile for Node {
    fn compile(
        &self,
        codegen: &mut CodeGen,
        ctx: ContexInfo,
        dbg_info: bool,
    ) -> Result<(), String> {
        match self {
            Node::String(val) => {
                if !ctx.drop_ret {
                    codegen.append_code(&format!("rt_new_symbol(\"{val}\");"))
                }
                Ok(())
            }
            Node::Number(Number::Float(val)) => {
                if !ctx.drop_ret {
                    codegen.append_code(&format!("rt_new_float({val});"))
                }
                Ok(())
            }
            Node::Number(Number::Int(val)) => {
                if !ctx.drop_ret {
                    codegen.append_code(&format!("rt_new_integer({val});"))
                }
                Ok(())
            }
            Node::Pair(car, cdr) => match &*car.borrow() {
                Node::Number(num) => Err(format!("{num} can not be the head of a list")),
                Node::SpecialForm(form) => match form {
                    // This corresponds to the apply part of the interpreter.
                    // Other objects' application are deferred to run-time, but
                    // special forms must be applied at compile-time.
                    SpecialForm::Lambda => {
                        if !ctx.drop_ret {
                            let (pattern, body) = cdr.borrow().as_pair()?;

                            // Use `begin` to support multiple statements.
                            let mut body =
                                Node::Pair(Node::SpecialForm(SpecialForm::Begin).into(), body);

                            let lambda_id = inc();

                            // Replace operands with its index.
                            let pattern = Pattern::try_from(pattern.clone())?;
                            let mut pvec = vec![];
                            pattern.vectorize(&mut pvec);
                            for (i, sym) in pvec.iter().enumerate() {
                                body.replace(
                                    &Node::Symbol(Symbol::User(sym.clone())),
                                    &Node::Symbol(Symbol::User(format!("#{i}_func_{lambda_id}"))),
                                );
                            }

                            // Generate function body.
                            let mut lambda_gen = CodeGen::new_internal(lambda_id);
                            // The lambda body should not drop the return value,
                            // but it can drop the environment as it is just a
                            // copy of current environment and no one will use it.
                            // This is how Relic do tail-recursive optimization.
                            let ctx = ContexInfo {
                                drop_env: true,
                                drop_ret: false,
                            };
                            body.compile(&mut lambda_gen, ctx, dbg_info)?;
                            codegen.merge(lambda_gen);

                            // Write the code that creates the closure.
                            codegen.append_code(&format!(
                                "rt_new_closure(\"{lambda_id}\", func_{lambda_id}, {}, {});",
                                pvec.len(),
                                !pattern.is_proper_list()
                            ));
                        }
                        Ok(())
                    }
                    SpecialForm::Display => {
                        let params = get_n_params(cdr.clone(), 1)?;
                        // Keep the node to display.
                        params[0].borrow().compile(
                            codegen,
                            ContexInfo {
                                drop_env: ctx.drop_env,
                                drop_ret: false,
                            },
                            dbg_info,
                        )?;
                        codegen.append_code(
                            r#"
printf("%s",rt_display_node_idx(rt_pop()));
fflush(NULL);"#,
                        );
                        return_nil!(codegen, ctx);
                        Ok(())
                    }
                    SpecialForm::NewLine => {
                        let _ = get_n_params(cdr.clone(), 0)?;
                        codegen.append_code("printf(\"\\n\");");
                        return_nil!(codegen, ctx);
                        Ok(())
                    }
                    SpecialForm::BreakPoint => {
                        let _ = get_n_params(cdr.clone(), 0)?;
                        codegen.append_code("rt_breakpoint();");
                        return_nil!(codegen, ctx);
                        Ok(())
                    }
                    SpecialForm::Define => {
                        let params = get_n_params(cdr.clone(), 2)?;
                        if ctx.drop_env {
                            // The environment will be dropped anyway.
                            Ok(())
                        } else if let Node::Symbol(Symbol::User(name)) = &*params[0].borrow() {
                            // `define` uses both of the environment and the return value.
                            // So do `set*`.
                            params[1].borrow().compile(
                                codegen,
                                ContexInfo {
                                    drop_env: false,
                                    drop_ret: false,
                                },
                                dbg_info,
                            )?;
                            codegen.append_code(&format!("rt_define(\"{name}\", rt_pop());"));
                            return_nil!(codegen, ctx);
                            Ok(())
                        } else {
                            Err(format!(
                                "{} is not a user defined symbol",
                                params[0].borrow()
                            ))
                        }
                    }
                    SpecialForm::Set => {
                        set_family!(
                            "set",
                            |name| { format!("\"{name}\"") },
                            cdr,
                            codegen,
                            ctx,
                            dbg_info
                        )
                    }
                    SpecialForm::SetCar => {
                        set_family!(
                            "set_car",
                            |name| { format!("rt_get(\"{name}\")") },
                            cdr,
                            codegen,
                            ctx,
                            dbg_info
                        )
                    }
                    SpecialForm::SetCdr => {
                        set_family!(
                            "set_cdr",
                            |name| { format!("rt_get(\"{name}\")") },
                            cdr,
                            codegen,
                            ctx,
                            dbg_info
                        )
                    }
                    SpecialForm::If => {
                        // The value and environment of precondition must be preserved;
                        // those of the branches can be dropped.
                        let params = get_n_params(cdr.clone(), 3)?;
                        params[0].borrow().compile(
                            codegen,
                            ContexInfo {
                                drop_env: false,
                                drop_ret: false,
                            },
                            dbg_info,
                        )?;
                        codegen.append_code("if (rt_get_bool(rt_pop()) > 0) {");
                        params[1].borrow().compile(codegen, ctx, dbg_info)?;
                        codegen.append_code("} else {");
                        params[2].borrow().compile(codegen, ctx, dbg_info)?;
                        codegen.append_code("}");
                        Ok(())
                    }
                    SpecialForm::Quote => {
                        if !ctx.drop_ret {
                            let params = get_n_params(cdr.clone(), 1)?;
                            codegen.append_code(&format!(
                                "rt_new_constant(\"{}\");",
                                params[0].borrow()
                            ));
                        }
                        Ok(())
                    }
                    SpecialForm::Begin => {
                        let operands = vectorize(cdr.clone())?;
                        if !operands.is_empty() {
                            for i in 0..operands.len() - 1 {
                                // Keep environment, drop result
                                operands[i].borrow().compile(
                                    codegen,
                                    ContexInfo {
                                        drop_env: false,
                                        drop_ret: true,
                                    },
                                    dbg_info,
                                )?;
                            }
                            operands
                                .last()
                                .unwrap()
                                .borrow()
                                .compile(codegen, ctx, dbg_info)?;
                        }
                        Ok(())
                    }
                    SpecialForm::Import => {
                        let params = get_n_params(cdr.clone(), 1)?;
                        codegen.append_code(&format!("rt_import(\"{}\");", params[0].borrow()));
                        return_nil!(codegen, ctx);
                        Ok(())
                    }
                    SpecialForm::Graphviz => todo!(),
                    _ => unreachable!(),
                },
                _ => {
                    let operands = vectorize(cdr.clone())?;
                    let len_operands = operands.len();

                    // Keep environment and result
                    for operand in operands.iter().rev() {
                        operand.borrow().compile(
                            codegen,
                            ContexInfo {
                                drop_env: false,
                                drop_ret: false,
                            },
                            dbg_info,
                        )?;
                    }

                    car.borrow().compile(
                        codegen,
                        ContexInfo {
                            drop_env: false,
                            drop_ret: false,
                        },
                        dbg_info,
                    )?;

                    let call_closure = if ctx.drop_env {
                        format!(
                            r#"
rt_add_root("__closure", rt_pop());
rt_prepare_args(rt_get_root("__closure"), {len_operands});
c_func func = rt_get_c_func(rt_remove_root("__closure"));
func();
"#
                        )
                    } else {
                        format!(
                            r#"
rt_add_root("__old_env", rt_current_env());
rt_add_root("__closure", rt_pop());
rt_prepare_args(rt_get_root("__closure"), {len_operands});
rt_push(rt_remove_root("__old_env"));
c_func func = rt_get_c_func(rt_remove_root("__closure"));
func();
rt_swap();
rt_move_to_env(rt_pop());
"#
                        )
                    };

                    codegen.append_code(&format!(
                        r#"
if (rt_is_symbol(rt_top())) {{
    rt_apply({len_operands});
}} else {{
    {call_closure}
}}"#
                    ));

                    // Drop the result if the caller wants to drop it.
                    if ctx.drop_ret {
                        codegen.append_code("rt_pop();");
                    }
                    Ok(())
                }
            },
            Node::SpecialForm(_) => unreachable!(),
            Node::Symbol(sym) => sym.compile(codegen, ctx, dbg_info),
        }?;
        if dbg_info {
            let self_str = self.to_string();
            let self_str = self_str.replace("\"", "'");
            codegen.append_code(&format!(
                "rt_evaluated(\"{}\", {});",
                self_str,
                if ctx.drop_ret { 1 } else { 0 }
            ));
        }
        Ok(())
    }
}
