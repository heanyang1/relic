use std::{
    cell::RefCell, collections::HashMap, fmt::Display, mem::swap, rc::Rc, result::Result, vec::Vec,
};

use crate::{
    env::Env,
    lexer::{Lexer, Number, TokenType},
    logger::{log_debug, log_error},
    node::Node,
    symbol::Symbol,
    util::{CVoidFunc, eval_arith, eval_rel, map_to_assoc_lst},
};

/// Closures.
///
/// This is probably the easiest way to represent lambdas using C function.
/// See [this blog post](https://matt.might.net/articles/closure-conversion/)
/// for details.
///
/// Our closure is even simpler than that in the blog post. The function accepts
/// no argument and extracts its arguments from current environment and stack.
/// It pushes its return value to the stack when finished.
#[derive(Debug, Clone, Eq)]
pub struct Closure {
    /// Closure ID generated by compiler. It should be the same as the one in
    /// the code generator.
    pub(crate) id: usize,
    /// The function body.
    pub(crate) body: CVoidFunc,
    /// The environment where the closure is constructed.
    pub(crate) env: usize,
    /// Number of arguments.
    pub(crate) nargs: usize,
    /// Whether the closure is variadic. If it is `true`, then the last argument
    /// of the closure is the list of remaining arguments.
    pub(crate) variadic: bool,
}

impl PartialEq for Closure {
    fn eq(&self, _: &Self) -> bool {
        panic!("Comparing closures")
    }
}

impl Closure {
    pub fn new(
        id: usize,
        body: CVoidFunc,
        nargs: usize,
        variadic: bool,
        runtime: &Runtime,
    ) -> Closure {
        Closure {
            id,
            body,
            env: runtime.current_env(),
            nargs,
            variadic,
        }
    }
}

// Environment manipulation.
impl Env<String, usize, Runtime> for usize {
    fn top(runtime: &mut Runtime) -> Self {
        runtime.top_env()
    }
    fn get_cur(&self, key: &String, runtime: &Runtime) -> Option<usize> {
        runtime.get_cur_env(*self, key)
    }
    fn do_in_outer<Out, F>(&self, func: F, runtime: &Runtime) -> Out
    where
        F: Fn(&Self) -> Out,
        Self: Sized,
    {
        // `outer = ...` and `func(...)` acquire and release the lock respectively
        // so they must be separated into two statements.
        let outer = runtime.get_outer_env(*self);
        func(&outer.unwrap())
    }
    fn do_in_outer_mut<Out, F>(&mut self, func: F, runtime: &mut Runtime) -> Out
    where
        F: Fn(&mut Self, &mut Runtime) -> Out,
        Self: Sized,
    {
        let outer = runtime.get_outer_env(*self);
        func(&mut outer.unwrap(), runtime)
    }
    fn has_outer(&self, runtime: &Runtime) -> bool {
        runtime.get_outer_env(*self).is_some()
    }
    fn insert_cur(&mut self, key: &String, value: usize, runtime: &mut Runtime) {
        runtime.insert_cur_env(*self, key, value);
    }
}

/// The runtime data node. A runtime data node is owned by the garbage
/// collector and is used by the user to store data structures at run-time.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RuntimeNode {
    /// Symbols.
    Symbol(Symbol),
    /// Numbers.
    Number(Number),
    /// Pair of nodes.
    Pair(usize, usize),
    /// Environments.
    /// Fields are: (Name, Variable map, Outer environment)
    Environment(String, HashMap<String, usize>, Option<usize>),
    /// Closures.
    Closure(Closure),
    /// Indicates the data is moved to the [data field] position of the other area.
    BrokenHeart(usize),
}

/// The runtime.
///
/// To simplify bindings and avoid ownership issues, users can only get the
/// index of the runtime node in the GC area. There are functions that retrives
/// the content of the node through index.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Runtime {
    /// The stack. Its content is the index to the element in the GC area.
    ///
    /// The stack element won't be GCed.
    stack: Vec<usize>,
    /// The GC area is split into two halves.
    /// The first one is always the one being used.
    areas: (Vec<RuntimeNode>, Vec<RuntimeNode>),
    /// Size of the GC area in pairs.                            
    size: usize,
    /// Root variables that won't be GCed.
    ///
    /// The key is its name and the value is its index.
    roots: HashMap<String, usize>,
}

impl Display for Runtime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "area: [")?;
        for node in 0..self.areas.0.len() {
            write!(f, "{} ", self.display_node_idx(node))?;
        }
        writeln!(f, "]")?;
        write!(f, "stack: [")?;
        for node in self.stack.clone() {
            write!(f, "{} ", self.display_node_idx(node))?;
        }
        writeln!(f, "]")?;
        writeln!(f, "roots: [")?;
        for (name, node) in self.roots.clone() {
            writeln!(f, "\t{}: {}", name, self.display_node_idx(node))?;
        }
        writeln!(f, "]")?;
        Ok(())
    }
}

impl TryFrom<RuntimeNode> for Number {
    type Error = String;
    fn try_from(value: RuntimeNode) -> Result<Self, Self::Error> {
        if let RuntimeNode::Number(number) = value {
            Ok(number.clone())
        } else {
            Err("Not a number".to_string())
        }
    }
}

macro_rules! rel_op {
    ($runtime:expr, $nargs:expr, $op:tt) => {{
        let operands = $runtime.node_vec_from_stack($nargs);
        Ok($runtime.new_symbol(eval_rel(operands, |a, b| a $op b)?))
    }};
}

macro_rules! arith_op {
    ($runtime:expr, $nargs:expr, $op:tt) => {{
        let operands = $runtime.node_vec_from_stack($nargs);
        Ok($runtime.new_number(eval_arith(operands, |a, b| a $op b)?))
    }};
}

/// Unlike SICP's register machine model, our runtime uses a stack machine
/// to evaluate expression.
///
/// The `Item` can be either an operator or operand. We use the index of the
/// runtime node as `Item` in the runtime.
///
/// Here are some reasons to use stack machines (none of which will happen in
/// SICP's register machine, which is built on the top of a Scheme system):
/// - The problem of parsing assignment expressions is avoided.
/// `(assign a ((op +) (const 2) (reg x)))` can be done by pushing three items
/// and call `apply`, or by parsing the expression using a customized parser,
/// then walk down the AST. GC may be triggered during the process and the node
/// of `(const 2)` may be lost if you are not careful.
/// - In our implementation, stack operations are not slower than register
/// operation. The registers are implemented by a hash map and the stack is a
/// vector, both of them takes (amortized) O(1) time to insert and delete.
pub trait StackMachine<Item> {
    /// Push an item to the stack.
    fn push(&mut self, item: Item);
    /// Pop an item from the stack. Panics when stack underflow.
    fn pop(&mut self) -> Item;
    /// Get the top item from the stack. Doesn't pop the item. Panics when
    /// stack underflow.
    fn top(&mut self) -> Item;
    /// Pop one item as operator and `usize` items as operands, evaluate the
    /// expression, then push the result into the stack.
    fn apply(&mut self, nargs: usize) -> Result<(), String>;
}

impl StackMachine<usize> for Runtime {
    fn push(&mut self, index: usize) {
        self.stack.push(index);
    }
    fn pop(&mut self) -> usize {
        self.stack.pop().expect("Stack underflow")
    }
    fn top(&mut self) -> usize {
        *self.stack.iter().last().expect("Stack underflow")
    }
    fn apply(&mut self, nargs: usize) -> Result<(), String> {
        let index = self.pop();
        let operator = self.get_symbol(index)?;
        let ret = match operator {
            Symbol::Add => arith_op!(self, nargs, +),
            Symbol::Mul => arith_op!(self, nargs, *),
            Symbol::Sub => arith_op!(self, nargs, -),
            Symbol::Div => arith_op!(self, nargs, /),
            Symbol::Eq => {
                assert_eq!(nargs, 2);
                let lhs = self.pop_as_node();
                let rhs = self.pop_as_node();
                Ok(self.new_symbol(if lhs == rhs { Symbol::T } else { Symbol::Nil }))
            }
            Symbol::EqNum => rel_op!(self, nargs, ==),
            Symbol::Gt => rel_op!(self, nargs, >),
            Symbol::Lt => rel_op!(self, nargs, <),
            Symbol::Ge => rel_op!(self, nargs, >=),
            Symbol::Le => rel_op!(self, nargs, <=),
            Symbol::Atom => {
                assert_eq!(nargs, 1);
                let val = self.pop_as_node();
                Ok(self.new_symbol(if let RuntimeNode::Pair(_, _) = val {
                    Symbol::T
                } else {
                    Symbol::Nil
                }))
            }
            Symbol::Car => {
                assert_eq!(nargs, 1);
                let val = self.pop_as_node();
                if let RuntimeNode::Pair(car, _) = val {
                    Ok(car)
                } else {
                    Err("Not a pair".to_string())
                }
            }
            Symbol::Cdr => {
                assert_eq!(nargs, 1);
                let val = self.pop_as_node();
                if let RuntimeNode::Pair(_, cdr) = val {
                    Ok(cdr)
                } else {
                    Err("Not a pair".to_string())
                }
            }
            Symbol::Cons => {
                assert_eq!(nargs, 2);
                let car = self.pop();
                let cdr = self.pop();
                Ok(self.new_pair(car, cdr))
            }
            Symbol::List => {
                let operands = self.node_vec_from_stack(nargs);
                Ok(self.vec_to_node(operands))
            }
            Symbol::Nil => Ok(self.get_root("nil")),
            Symbol::T => Ok(self.get_root("t")),
            Symbol::Number => {
                assert_eq!(nargs, 1);
                if let RuntimeNode::Number(_) = self.pop_as_node() {
                    Ok(self.get_root("t"))
                } else {
                    Ok(self.get_root("nil"))
                }
            }
            // Calling `call_closure` here causes deadlock.
            Symbol::User(_) => panic!("Use `call_closure` to apply closure"),
        }?;
        self.push(ret);
        Ok(())
    }
}

impl Runtime {
    pub fn node_vec_from_stack(&mut self, nargs: usize) -> Vec<RuntimeNode> {
        let mut operands = vec![];
        for _ in 0..nargs {
            let idx = self.pop();
            let node = self.get_node(true, idx).clone();
            operands.push(node);
        }
        operands
    }

    pub fn vec_to_node(&mut self, operands: Vec<RuntimeNode>) -> usize {
        let lst = self.new_symbol(Symbol::Nil);
        self.push(lst);
        for node in operands.iter().rev() {
            let car = self.new_node_with_gc(node.clone());
            let cdr = self.pop();
            let pair = self.new_pair(car, cdr);
            self.push(pair);
        }
        self.pop()
    }

    fn pop_as_node(&mut self) -> RuntimeNode {
        let index = self.pop();
        self.get_node(true, index).clone()
    }

    fn get_area(&self, active: bool) -> &Vec<RuntimeNode> {
        if active {
            self.areas.0.as_ref()
        } else {
            self.areas.1.as_ref()
        }
    }
    fn get_area_mut(&mut self, active: bool) -> &mut Vec<RuntimeNode> {
        if active {
            self.areas.0.as_mut()
        } else {
            self.areas.1.as_mut()
        }
    }

    fn to_node(
        &self,
        index: usize,
        visited: &mut HashMap<usize, Rc<RefCell<Node>>>,
    ) -> Rc<RefCell<Node>> {
        if visited.contains_key(&index) {
            return visited.get(&index).unwrap().clone();
        }
        match self.get_node(true, index) {
            RuntimeNode::BrokenHeart(dst) => {
                Node::Symbol(Symbol::User(format!("<BrokenHeart {dst}>"))).into()
            }
            RuntimeNode::Closure(Closure { env, nargs, .. }) => Node::Symbol(Symbol::User(
                format!("<Closure env: {env}, nargs: {nargs}>"),
            ))
            .into(),
            RuntimeNode::Environment(name, map, outer) => {
                let mut result = format!("<Env {name}: ");
                for (k, v) in map {
                    result += &format!("{k}={v}, ");
                }
                if let Some(env) = outer {
                    result += &format!("; outer = {env}");
                }
                Node::Symbol(Symbol::User(format!("{result}>"))).into()
            }
            RuntimeNode::Number(val) => Node::Number(val.clone()).into(),
            RuntimeNode::Pair(car, cdr) => {
                let pair = Rc::new(RefCell::new(Node::Pair(
                    Node::Symbol(Symbol::Nil).into(),
                    Node::Symbol(Symbol::Nil).into(),
                )));
                visited.insert(index, pair.clone());
                let car_node = self.to_node(*car, visited);
                let cdr_node = self.to_node(*cdr, visited);
                if let Node::Pair(car, cdr) = &mut *pair.borrow_mut() {
                    *car = car_node;
                    *cdr = cdr_node;
                } else {
                    unreachable!()
                }
                pair
            }
            RuntimeNode::Symbol(val) => Node::Symbol(val.clone()).into(),
        }
    }

    // GC and maintain the fields of `gc_area`.
    fn gc(&mut self) {
        log_debug(&format!("Before GC: {self}"));
        let old_free = self.get_free();
        self.areas.1.clear();

        // Move all roots elements.
        for (name, root) in map_to_assoc_lst(&self.roots) {
            let new_root = self.gc_dfs(root);
            self.set_root(name, new_root);
        }
        // Move all stack elements.
        let new_stack = self.stack.clone();
        self.stack.clear();
        for elem in new_stack {
            let new_elem = self.gc_dfs(elem);
            self.stack.push(new_elem);
        }

        swap::<Vec<RuntimeNode>>(self.areas.0.as_mut(), self.areas.1.as_mut());
        if self.get_free() == old_free {
            // GC doesn't reclaim any memory. Increase the area size.
            self.size *= 2;
        }
        log_debug(&format!("After GC: {self}"));
    }
    // Try to call `gc()`.
    // Doesn't perform GC if there's enough memory to alloc a pair.
    pub fn try_gc(&mut self) {
        let old_free = self.get_free();
        if old_free < self.size {
            return;
        }
        self.gc();
    }
    fn gc_dfs(&mut self, cur: usize) -> usize {
        let node = self.get_node(true, cur);
        if let RuntimeNode::BrokenHeart(dst) = node {
            return *dst;
        }

        let dst_length = self.get_area(false).len();
        {
            // Allocate the space for the new item and invalidate the old item
            // to avoid calling `gc_dfs` on the same item again
            let node = node.clone();
            let dst_area = self.get_area_mut(false);
            dst_area.push(node);
            let src_area = self.get_area_mut(true);
            src_area[cur] = RuntimeNode::BrokenHeart(dst_length);
        }

        let content = match self.get_node(false, dst_length) {
            RuntimeNode::BrokenHeart(_) => panic!("Already moved"),
            RuntimeNode::Closure(Closure {
                id,
                body,
                env,
                nargs,
                variadic,
            }) => {
                let id = *id;
                let body = *body;
                let nargs = *nargs;
                let variadic = *variadic;
                let env = self.gc_dfs(*env);
                RuntimeNode::Closure(Closure {
                    id,
                    body,
                    env,
                    nargs,
                    variadic,
                })
            }
            RuntimeNode::Environment(env_name, map, outer) => {
                let outer_clone = *outer;
                let env_name_clone = env_name.clone();
                let mut new_map = HashMap::new();
                for (name, var) in map_to_assoc_lst(map) {
                    new_map.insert(name, self.gc_dfs(var));
                }
                let new_outer = outer_clone.map(|val| self.gc_dfs(val));
                RuntimeNode::Environment(env_name_clone, new_map, new_outer)
            }
            RuntimeNode::Pair(car, cdr) => {
                let (car_val, cdr_val) = (*car, *cdr);
                let new_car = self.gc_dfs(car_val);
                let new_cdr = self.gc_dfs(cdr_val);
                RuntimeNode::Pair(new_car, new_cdr)
            }
            _ => self.get_node(false, dst_length).clone(),
        };
        let dst_area = self.get_area_mut(false);
        dst_area[dst_length] = content;
        dst_length
    }

    /// Insert a node into GC area.
    ///
    /// GC area must have enough space to insert the node. You should not use
    /// this unless you want to pin some variables to GC area.
    fn new_node(&mut self, node: RuntimeNode) -> usize {
        let result = self.get_free();
        assert!(result < self.size);
        self.get_area_mut(true).push(node);
        result
    }

    /// Perform GC and insert a node into GC area.
    fn new_node_with_gc(&mut self, node: RuntimeNode) -> usize {
        self.try_gc();
        self.new_node(node)
    }
}

// Create C bindings for these functions.
impl Runtime {
    pub fn new(size: usize) -> Runtime {
        Runtime {
            stack: vec![],
            areas: (Vec::with_capacity(size), Vec::with_capacity(size)),
            size,
            roots: HashMap::new(),
        }
    }

    pub fn add_root(&mut self, name: String, value: usize) {
        assert!(!self.roots.contains_key(&name));
        self.roots.insert(name, value);
    }
    pub fn set_root(&mut self, name: String, value: usize) {
        self.roots.insert(name, value);
    }
    pub fn remove_root(&mut self, name: &str) -> usize {
        self.roots.remove(name).unwrap()
    }

    pub fn get_root(&self, name: &str) -> usize {
        *self.roots.get(name).unwrap()
    }

    pub fn get_free(&self) -> usize {
        self.get_area(true).len()
    }
    pub fn get_size(&self) -> usize {
        self.size
    }

    pub fn get_number(&self, index: usize) -> Result<Number, String> {
        if let RuntimeNode::Number(val) = self.get_node(true, index) {
            Ok(val.clone())
        } else {
            Err(format!("{} is not a number", self.display_node_idx(index)))
        }
    }
    pub fn get_symbol(&self, index: usize) -> Result<Symbol, String> {
        if let RuntimeNode::Symbol(val) = self.get_node(true, index) {
            Ok(val.clone())
        } else {
            Err(format!("{} is not a symbol", self.display_node_idx(index)))
        }
    }

    pub fn set_car(&mut self, active: bool, index: usize, target: usize) -> Result<(), String> {
        let area = self.get_area_mut(active);
        let box_val = area.get_mut(index).unwrap();
        if let RuntimeNode::Pair(car, _) = box_val {
            *car = target;
            Ok(())
        } else {
            Err(format!("{} is not a pair", self.display_node_idx(index)))
        }
    }

    pub fn set_cdr(&mut self, active: bool, index: usize, target: usize) -> Result<(), String> {
        let area = self.get_area_mut(active);
        let box_val = area.get_mut(index).unwrap();
        if let RuntimeNode::Pair(_, cdr) = box_val {
            *cdr = target;
            Ok(())
        } else {
            Err(format!("{} is not a pair", self.display_node_idx(index)))
        }
    }

    pub fn display_node_idx(&self, index: usize) -> String {
        let mut visited = HashMap::new();
        let node = self.to_node(index, &mut visited);
        format!("{}", node.borrow())
    }

    pub fn new_pair(&mut self, mut car: usize, mut cdr: usize) -> usize {
        // Pin the two pointers so they won't be lost in GC.
        self.push(car);
        self.push(cdr);

        self.try_gc();

        // Unpin them.
        cdr = self.pop();
        car = self.pop();

        self.new_node(RuntimeNode::Pair(car, cdr))
    }

    pub fn new_number(&mut self, val: Number) -> usize {
        self.new_node_with_gc(RuntimeNode::Number(val))
    }

    pub fn new_symbol(&mut self, val: Symbol) -> usize {
        self.new_node_with_gc(RuntimeNode::Symbol(val))
    }

    pub fn new_closure(&mut self, val: Closure) -> usize {
        self.new_node_with_gc(RuntimeNode::Closure(val))
    }

    pub fn new_constant(&mut self, expr: &str) -> Result<usize, String> {
        let mut tokens = Lexer::new(expr);
        let index = usize::parse(&mut tokens, self)?;
        Ok(index)
    }

    pub fn new_env(&mut self, name: String, mut outer: usize) -> usize {
        self.push(outer);

        self.try_gc();

        outer = self.pop();
        self.new_node(RuntimeNode::Environment(name, HashMap::new(), Some(outer)))
    }

    pub fn current_env(&self) -> usize {
        let env_name = "__cur_env";
        *self.roots.get(env_name).unwrap()
    }
}

// These functions are supposed to be used by other objects in the crate.
// DO NOT create C bindings for them although they are public.
impl Runtime {
    pub fn get_node(&self, active: bool, index: usize) -> &RuntimeNode {
        self.get_area(active).get(index).unwrap()
    }

    pub fn get_node_mut(&mut self, active: bool, index: usize) -> &mut RuntimeNode {
        self.get_area_mut(active).get_mut(index).unwrap()
    }

    pub fn top_env(&mut self) -> usize {
        let top_name = "__cur_env";
        assert!(!self.roots.contains_key(top_name));
        let node = self.new_node_with_gc(RuntimeNode::Environment(
            "top".to_string(),
            HashMap::new(),
            None,
        ));
        self.roots.insert(top_name.to_string(), node);
        node
    }

    pub fn get_cur_env(&self, idx: usize, key: &String) -> Option<usize> {
        if let RuntimeNode::Environment(_, map, _) = self.get_node(true, idx) {
            map.get(key).copied()
        } else {
            log_error(&format!(
                "Expect an environment, found {}",
                self.display_node_idx(idx),
            ));
            None
        }
    }

    pub fn move_to_env(&mut self, env: usize) {
        if let RuntimeNode::Environment(_, _, _) = self.get_node(true, env) {
            self.set_root("__cur_env".to_string(), env);
        } else {
            panic!("Not an environment")
        }
    }

    pub fn get_outer_env(&self, idx: usize) -> Option<usize> {
        if let RuntimeNode::Environment(_, _, outer) = self.get_node(true, idx) {
            *outer
        } else {
            panic!("Not an environment")
        }
    }

    pub fn insert_cur_env(&mut self, idx: usize, key: &String, value: usize) {
        if let RuntimeNode::Environment(_, map, _) = self.get_node_mut(true, idx) {
            map.insert(key.to_string(), value);
        } else {
            panic!("Not an environment")
        }
    }
}

// Debug functions.
impl Runtime {
    pub fn debug_force_gc(&mut self) {
        self.gc();
    }
}

pub trait RuntimeParse {
    fn parse(tokens: &mut Lexer, runtime: &mut Runtime) -> Result<Self, String>
    where
        Self: Sized;
}

impl RuntimeParse for usize {
    fn parse(tokens: &mut Lexer, runtime: &mut Runtime) -> Result<Self, String>
    where
        Self: Sized,
    {
        match tokens.next() {
            Some(TokenType::LParem) => parse_list(tokens, runtime),
            Some(TokenType::Quote) => panic!("You don't need to quote in the runtime."),
            Some(TokenType::Number(i)) => Ok(runtime.new_number(i)),
            Some(TokenType::Symbol(symbol)) => Ok(runtime.new_symbol(symbol.into())),
            Some(TokenType::RParem) => Err(format!(
                "At position {}: Unexpected \")\"",
                tokens.get_cur_pos()
            )),
            Some(TokenType::Dot) => Err(format!(
                "At position {}: Unexpected \".\"",
                tokens.get_cur_pos()
            )),
            Some(TokenType::Comment) => Self::parse(tokens, runtime),
            None => Err("Unexpected EOF while parsing".to_string()),
        }
    }
}
/// The same as `Node::parse_list`, except that it deals with the runtime.
fn parse_list(tokens: &mut Lexer, runtime: &mut Runtime) -> Result<usize, String> {
    match tokens.peek_next_token().1 {
        Some(TokenType::RParem) => {
            // case 1
            tokens.consume(TokenType::RParem).unwrap();
            Ok(runtime.new_symbol(Symbol::Nil))
        }
        Some(TokenType::Comment) => {
            tokens.consume(TokenType::Comment).unwrap();
            parse_list(tokens, runtime)
        }
        _ => {
            let mut car = usize::parse(tokens, runtime)?;
            runtime.push(car);

            let cdr = if let Some(TokenType::Dot) = tokens.peek_next_token().1 {
                // case 2
                tokens.consume(TokenType::Dot).unwrap();
                let cdr = usize::parse(tokens, runtime)?;
                tokens.consume(TokenType::RParem)?;
                cdr
            } else {
                // case 3
                parse_list(tokens, runtime)?
            };

            car = runtime.pop();

            let pair = runtime.new_pair(car, cdr);
            Ok(pair)
        }
    }
}
